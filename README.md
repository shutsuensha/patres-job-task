## Title
Начало:
Завершение:






### Local
create local dotabase via psql - main
create local test dtabase via psql - test

(example)

sudo -i -u postgres
psql

CREATE DATABASE main_postgresql_database;
CREATE USER myuser WITH ENCRYPTED PASSWORD 'mypassword';
GRANT ALL PRIVILEGES ON DATABASE main_postgresql_database TO myuser;



CREATE DATABASE test_postgresql_database;
CREATE USER myuser WITH ENCRYPTED PASSWORD 'mypassword';
GRANT ALL PRIVILEGES ON DATABASE test_postgresql_database TO myuser;



fill .env by .env.example

POSTGRES_DB_HOST=localhost
POSTGRES_DB_PORT=5432
POSTGRES_DB_USER=myuser
POSTGRES_DB_PASS=mypassword
POSTGRES_DB_NAME=main_postgresql_database

JWT_SECRET_KEY=    # openssl rand -hex 32 
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

TEST_POSTGRES_DB_HOST=localhost
TEST_POSTGRES_DB_PORT=5432
TEST_POSTGRES_DB_USER=myuser
TEST_POSTGRES_DB_PASS=mypassword
TEST_POSTGRES_DB_NAME=test_postgresql_database

python3 -m venv .venv
pip3 install -r requirements.txt

alembic upgrade head

uvicorn app.main:app --reload

go localhost:8000/docs
librariant - register - email/password
Auth button fill username - your email, password

pytest

--------------------------------------------------
psql -U evalshine -d mydatabase23123;
psql -U evalshine -d test213dawd;

alembic revision --autogenerate -m "init"
alembic upgrade head

ruff check --fix
ruff format

pytest
---------------------------------------------------



### Docker

fill .env by .env.example

POSTGRES_DB_HOST=postgre_container
POSTGRES_DB_PORT=5432
POSTGRES_DB_USER=myuser
POSTGRES_DB_PASS=mypassword
POSTGRES_DB_NAME=main_postgresql_database

JWT_SECRET_KEY=    # openssl rand -hex 32 
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

TEST_POSTGRES_DB_HOST=postgre_container_test
TEST_POSTGRES_DB_PORT=5432
TEST_POSTGRES_DB_USER=myuser
TEST_POSTGRES_DB_PASS=mypassword
TEST_POSTGRES_DB_NAME=test_postgresql_database


docker network create library-network
docker build -t fastapi-image-library-api -f Dockerfile .
docker compose -f docker-compose-services.yml up -d
docker compose -f docker-compose.yml up -d
docker run --rm --network library-network fastapi-image-library-api alembic upgrade head

go localhost:80/docs
librariant - register - email/password
Auth button fill username - your email, password

docker run --rm --network library-network fastapi-image-library-api pytest












## Стрктура проекта
```
my_project/
├── app/
│   ├── main.py              # Точка входа, создание FastAPI-инстанса
│   ├── api/
│   │   └── v1/
│   │       ├── routes/
│   │       │   ├── users.py
│   │       │   ├── librarians.py
│   │       │   ├── borrow.py
│   │       │   └── books.py
│   │       └── api.py       # Сборка всех роутов в один APIRouter
│   ├── core/
│   │   ├── config.py        # Настройки (env, config)
│   │   └── security.py      # Функции для хеширования паролей, JWT, токенов
│   ├── db/
│   │   └── database.py      # Подключение к базе данных
│   ├── dependencies/        # Зависимости для аутентификации и подключения к БД
│   │   ├── auth.py          
│   │   ├── db.py           
│   ├── migrations/          # Миграции Alembic
│   │   ├── env.py
│   │   ├── script.py.mako
│   │   └── versions/
│   │       └── <файлы миграций>.py
│   ├── models/              # SQLAlchemy модели
│   │   ├── base.py          
│   │   ├── user.py          
│   │   ├── book.py          
│   │   ├── borrowed_book.py
│   │   └── librarian.py     
│   ├── schemas/
│   │   ├── user.py          # Pydantic-схемы: UserIn, UserOut, ...
│   │   ├── book.py
│   │   ├── borrow.py
│   │   └── librarian.py
│   └── services/            # Бизнес логика - сервисный слой
│       ├── user_service.py
│       ├── book_service.py
│       ├── borrow_service.py
│       └── librarian_service.py
├── tests/
│   ├── integration_tests/   # Интеграционные тесты для всего цикла обработки запроса
│   ├── unit_tests/          # Тесты для проверки бизнес логики
│   └── conftest.py  
├── .env                     
├── alembic.ini
├── docker-compose-services.yml  # postgresql, test postgresql контейнеры
├── docker-compose.yml  # fastapi, nginx контейнеры
├── Dockerfile          # fastapi сборка docker образа
├── nginx.conf          # nginx как обратный прокси сервер к fastapi контейнеру
├── pyproject.toml           # Конфигурационный файл ruff lint/format
├── requirements.txt
└── README.md
```

## Описание структуры базы данных и принятых решений

- **ORM и типизация**  
  Для описания моделей используется **SQLAlchemy ORM** с типами `Mapped` и функцией `mapped_column`.  
  Это современный и типобезопасный способ, который улучшает читаемость кода и поддержку в IDE, позволяя явно указывать типы и свойства колонок.

- **Обязательные и необязательные поля**  
  Обязательные поля имеют `nullable=False`, необязательные — `nullable=True`.  
  Это гарантирует целостность данных в базе, заставляя всегда указывать важные значения и позволяя пропускать незначимые поля.

- **Уникальные поля**  
  Уникальные поля, такие как `email` в моделях `User` и `Librarian`, или `isbn` в модели `Book`, помечены `unique=True`.  
  Это предотвращает дублирование данных и обеспечивает однозначную идентификацию записей.

- **Ограничения на поля**  
  В модели `Book` поле `copies_count`:
  - имеет ограничение `CheckConstraint` на неотрицательное значение,
  - устанавливает значение по умолчанию `default=1`.  
  Это гарантирует корректность данных и минимальное количество экземпляров книги по умолчанию.

- **Связи между таблицами**  
  Для связей между таблицами применяются внешние ключи (`ForeignKey`), которые:
  - обеспечивают ссылочную целостность,
  - гарантируют корректные связи между сущностями (например, `BorrowedBook` с `Book` и `User`).

- **Работа с датой и временем**  
  Поля, содержащие дату и время, используют тип `TIMESTAMP(timezone=True)` для поддержки временных зон.  
  Поле `borrow_date` имеет значение по умолчанию — текущую дату и время в UTC, что обеспечивает единообразие и точность временных данных.

- **Первичные ключи**  
  Все таблицы имеют поле `id` с параметрами `primary_key=True, autoincrement=True`.  
  Это обеспечивает уникальную идентификацию записей и поддержку целостности на уровне базы данных.


## Объяснение реализации бизнес-логики (4.1 и 4.2)

### Выдача книги с проверкой доступных экземпляров

Функция `borrow_book` реализует процесс выдачи книги следующим образом:

- **Начало транзакции**  
  Вся логика обёрнута в `async with session.begin()`, что обеспечивает атомарность операции: либо выполняются все действия, либо ни одно.

- **Захват строки книги с блокировкой**  
  Книга извлекается с помощью `SELECT ... FOR UPDATE`, что блокирует строку книги в базе данных до конца транзакции. Это предотвращает гонки за доступ к экземплярам книги при параллельных запросах.

- **Проверка существования книги**  
  Если книга с переданным `book_id` не найдена — возвращается ошибка 404.

- **Проверка существования пользователя**  
  Если пользователь с переданным `reader_id` не найден — также возвращается ошибка 404.

- **Проверка доступных копий**  
  Если `copies_count < 1`, операция блокируется с ошибкой 400 — книга недоступна для выдачи.

- **Проверка лимита на количество активных заимствований**  
  Выполняется SQL-запрос, считающий количество записей в `BorrowedBook`, у которых:
  - `reader_id` соответствует пользователю
  - `return_date IS NULL` — книга не возвращена

  Если у пользователя уже 3 активных книги, операция также блокируется ошибкой 400.

- **Создание записи о заимствовании**  
  В таблицу `BorrowedBook` добавляется новая запись с `book_id` и `reader_id`.

- **Уменьшение количества доступных копий книги**  
  Значение `copies_count` уменьшается на 1, что гарантирует актуальность состояния базы.

- **Обновление объекта для возврата**  
  После завершения транзакции вызывается `session.refresh(borrowed)`, чтобы вернуть актуальные данные о новой записи.

---

### Сложности и их решения

#### Сложность 1: Конкурентный доступ к количеству копий книги

**Проблема:**  
Если два пользователя одновременно попытаются взять книгу, у которой остался только один экземпляр, оба могут прочитать `copies_count = 1` и попытаться уменьшить его до 0.

**Решение:**  
Использование `SELECT ... FOR UPDATE` при чтении книги блокирует строку.  
Вторая транзакция будет ждать завершения первой. Если после этого `copies_count` будет равен нулю — сработает проверка `if book.copies_count < 1`, и операция завершится с ошибкой без изменения базы.  
Всё это работает в рамках транзакции `session.begin()` и предотвращает рассинхронизацию.

#### Сложность 2: Учёт активных заимствований пользователя

**Проблема:**  
Нужно учитывать только не возвращённые книги.

**Решение:**  
Используется фильтрация `return_date IS NULL`, что позволяет точно определить количество активных заимствований. Это обеспечивает корректную проверку перед выдачей новой книги.

#### Сложность 3: Обработка ошибок и обратная связь

**Проблема:**  
Пользователь должен получать понятные сообщения об ошибках: книга не найдена, пользователь не существует, нет копий, превышен лимит.

**Решение:**  
Каждая проверка сопровождается выбрасыванием `HTTPException` с соответствующим `status_code` и сообщением. Это делает поведение API предсказуемым и информативным для клиента.


## Объяснение реализации бизнес-логики (4.3)

Функция `return_book()` реализует бизнес-логику возврата книги и включает в себя следующие этапы:

### Проверка существования книги

Сначала осуществляется запрос на получение книги по `book_id`.  
Если книга не найдена — возвращается HTTP 404.

### Проверка существования читателя

Далее проверяется наличие пользователя по `reader_id`.  
Если пользователь не найден — также возвращается HTTP 404.

### Поиск активной записи о выдаче книги

Ищется запись в таблице `BorrowedBook`, удовлетворяющая условиям:

- `book_id` совпадает,
- `reader_id` совпадает,
- `return_date IS NULL` — то есть книга ещё не была возвращена.

Если такая запись не найдена — это значит, что либо книга не выдавалась этому читателю, либо она уже была возвращена ранее. В этом случае возвращается HTTP 404 с соответствующим сообщением.

### Возврат книги

Если активная запись найдена:

- Устанавливается значение `return_date` как текущая дата и время,
- Увеличивается поле `copies_count` у книги на 1.

### Транзакция

Операции выполняются в рамках транзакции `async with session.begin()`. Это гарантирует атомарность изменений: либо обе операции (обновление даты и количества экземпляров) будут выполнены, либо ни одна не будет применена в случае ошибки.

## Сложности и решения

### Сложность 1: Попытка вернуть книгу, которая не была выдана

**Решение:**  
Используется строгая фильтрация по `return_date IS NULL`.  
Если подходящая запись не найдена — возврат невозможен, возвращается HTTP 404.

### Сложность 2: Повторный возврат одной и той же книги

**Решение:**  
Повторный возврат исключён тем же фильтром `return_date IS NULL`. Уже возвращённые книги не могут быть найдены этим запросом, следовательно, операция невозможна.

### Сложность 3: Согласованность данных при обновлении

**Решение:**  
Обе связанные операции выполняются в рамках одной транзакции, что исключает частично сохранённые данные и поддерживает консистентность состояния базы.



## Реализация аутентификации в системе библиотекарей

### Как генерируются токены  
Функция `create_access_token(data: Dict[str, Any]) -> str` создаёт JWT-токен с полезной нагрузкой (data), в которую добавляется:  
- Время истечения срока действия токена (`exp`),  
- Тип токена (`sub: "access"`).  

Токен кодируется с помощью секретного ключа (`settings.JWT_SECRET_KEY`) и алгоритма (`settings.JWT_ALGORITHM`).

### Как проверяются токены  
В функции `get_current_user_id`:  
- Токен, полученный из заголовка авторизации (Bearer token) через `OAuth2PasswordBearer`, декодируется функцией `encode_token`.  
- Из полезной нагрузки извлекается `user_id`.  
- Если токен истёк или повреждён, вызывается исключение HTTP 401 Unauthorized.  
- Если `user_id` отсутствует, также вызывается 401 ошибка.  
- При успешной проверке возвращается `user_id` — идентификатор текущего аутентифицированного библиотекаря.

### Защищённые эндпоинты  
Так как у нас система для библиотекарей (для них login — генерирует токен Bearer, register — незащищены), после логина с токеном они управляют пользователями и книгами.  
Таким образом, мы даём доступ к управлению книгами и пользователями только зарегистрированным библиотекарям, прошедшим аутентификацию с использованием токена Bearer.

В нашем приложении библиотекарям выдаётся токен при логине (`/api/v1/librarians/login`).  
После успешной аутентификации все эндпоинты, связанные с управлением книгами и пользователями, используют зависимость:  
```python
librarian_id = Annotated[int, Depends(get_current_user_id)]
```
Это гарантирует, что доступ к ним имеют только авторизованные библиотекари с валидным Bearer-токеном.

### Используемые библиотеки

- **python-jose** — более надёжный и функционально полный выбор, особенно когда строится безопасная система, связанная с аутентификацией.

  - Поддерживает больше спецификаций и более строг по умолчанию (например, проверка истечения срока действия, сигнатуры и т.д.), что повышает безопасность.

- **OAuth2PasswordBearer** — FastAPI-зависимость, которая:

  - Ожидает токен в заголовке запроса (в формате `Authorization: Bearer <token>`),

  - Предназначена для OAuth2 "Resource Owner Password Credentials" потока (в вашем случае — логин по email/паролю, получение токена и использование его для доступа к API).

## Предложения

### Дополнительная фича: Улучшенная безопасность аутентификации с использованием Access/Refresh токенов, Token Rotation и Blacklisting

#### Идея фичи  
Для повышения безопасности защищённых эндпоинтов API я бы внедрил механизм разделения токенов на короткоживущие access токены и долгоживущие refresh токены с поддержкой token rotation и blacklisting.

- **Access токены** имеют небольшой срок действия (например, 15 минут) и используются для доступа к API.  
- **Refresh токены** действуют дольше (несколько дней или недель) и служат для получения новых access токенов без повторной аутентификации пользователя.  
- При каждом обновлении access токена по refresh токену, выдается новый refresh токен, а старый становится недействительным — это называется **token rotation**.  
- Для мгновенного аннулирования скомпрометированных токенов используется **blacklisting** — черный список токенов.

#### Как бы я реализовал  
- При логине пользователю выдаются и access, и refresh токены.  
- Refresh токены хранятся в Redis с уникальным идентификатором и сроком жизни.  
- При запросе обновления access токена:  
  - Проверяется наличие refresh токена в Redis.  
  - Если токен валиден — он удаляется из Redis (старый токен становится недействительным).  
  - Генерируются новые access и refresh токены.  
  - Новый refresh токен сохраняется в Redis.  
- При выходе пользователя или подозрении на компрометацию:  
  - Все связанные refresh токены удаляются или помещаются в blacklist в Redis, чтобы заблокировать дальнейшее обновление.  
- Access токены имеют короткий срок жизни, поэтому их черный список можно не реализовывать, либо реализовать при необходимости.

#### Почему это важно  
- Повышает безопасность: снижает риски повторного использования украденных refresh токенов.  
- Обеспечивает контроль: даёт возможность быстро блокировать доступ.  
- Удобство для пользователей: не требует частой повторной аутентификации, сохраняя баланс между безопасностью и юзабилити.


### Эндпоинт `GET /books`

Данный эндпоинт уже реализован как защищённый — требует JWT-токен библиотекаря.

Причина: доступ к каталогу предоставляется только библиотекарям, которые могут управлять книгами, отслеживать статусы выдачи и возврата, и видеть расширенные поля (например, кто взял книгу и когда).

Если бы система предусматривала интерфейс для читателей, можно было бы реализовать дополнительный публичный эндпоинт `/public/books`, который бы возвращал только название, автора и доступность книг.
